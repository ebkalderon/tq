// vim: ft=rust

use std::str::FromStr;

use ast::{BinaryOp, Expr, Ident, Key, Label, Stmt, Table, UnaryOp, Value, Variable};

use toml::value::Datetime;

grammar;

/// Variable types

Datetime: Datetime = {
    <date:r#"([0-9]+)-(0[1-9]|1[012])-(0[1-9]|[12][0-9]|3[01])[Tt ]([01][0-9]|2[0-3]):([0-5][0-9]):([0-5][0-9]|60)(\.[0-9]+)?(([Zz])?|([\+|\-]([01][0-9]|2[0-3]):[0-5][0-9]))"#>
    => Datetime::from_str(date).unwrap(),
    <date:r#"([0-9]+)-(0[1-9]|1[012])-(0[1-9]|[12][0-9]|3[01])"#>
    => Datetime::from_str(date).unwrap(),
    <date:r#"([01][0-9]|2[0-3]):([0-5][0-9]):([0-5][0-9]|60)(\.[0-9]+)?([\+|\-]([01][0-9]|2[0-3]):[0-5][0-9])?"#>
    => Datetime::from_str(date).unwrap(),
};

Float: f64 = <num:r"[0-9]+\.[0-9]+"> => f64::from_str(num).unwrap();
Integer: i64 = <num:r"[0-9]+"> => i64::from_str(num).unwrap();

String: String = {
    <r#""[^"\\]*((\\.)*[^"\\]*)*""#> => <>[1..(<>.len()-1)].to_owned(),
    <r#"'[^'\\]*((\\.)*[^'\\]*)*'"#> => <>[1..(<>.len()-1)].to_owned(),
    <r#"'''[^'''\\]*((\\.)*[^'''\\]*)*'''"#> => <>[3..(<>.len()-3)].to_owned(),
};

Value: Value = {
    "true" => Value::Boolean(true),
    "false" => Value::Boolean(false),
    <Float> => Value::Float(<>),
    <Integer> => Value::Integer(<>),
    <String> => Value::String(<>),
    <Datetime> => Value::Datetime(<>),
    "null" => Value::Null,
};

Ident: Ident = <r"[_\-a-zA-Z]+[_\-a-zA-Z0-9]*"> => Ident(<>.to_owned());
Label: Label = "$" <Ident> => Label(<>);
Variable: Variable = "$" <Ident> => Variable(<>);

Key: Key = {
    <Ident> => Key::Ident(<>),
    <String> => Key::String(<>),
};

Table: Table = {
    "{" <fields:(<Key> "=" <Expr> ",")*> <last:(<Key> "=" <Expr>)?> "}" => {
        let mut fields = fields;
        if let Some(last) = last {
            fields.push(last);
        }
        Table { fields }
    }
};

/// Expression types

pub Expr: Expr = <ExprPipe> => <>;

ExprPipe: Expr = {
    <l:ExprPipe> "|" <r:ExprComma> => Expr::Binary(BinaryOp::Pipe, Box::new(l), Box::new(r)),
    <ExprComma> => <>,
};

ExprComma: Expr = {
    <exprs:(<ExprEq> ",")+> <e:ExprEq> => {
        let mut exprs = exprs;
        exprs.push(e);
        Expr::Comma(exprs)
    },
    <ExprEq> => <>,
};

ExprEq: Expr = {
    <l:ExprEq> "==" <r:ExprCmp> => Expr::Binary(BinaryOp::Eq, Box::new(l), Box::new(r)),
    <l:ExprEq> "!=" <r:ExprCmp> => Expr::Binary(BinaryOp::NotEq, Box::new(l), Box::new(r)),
    <ExprCmp> => <>,
};

ExprCmp: Expr = {
    <l:ExprCmp> ">" <r:ExprBool> => Expr::Binary(BinaryOp::LessThan, Box::new(l), Box::new(r)),
    <l:ExprCmp> ">=" <r:ExprBool> => Expr::Binary(BinaryOp::LessThanEq, Box::new(l), Box::new(r)),
    <l:ExprCmp> "<" <r:ExprBool> => Expr::Binary(BinaryOp::GreaterThan, Box::new(l), Box::new(r)),
    <l:ExprCmp> "<=" <r:ExprBool> => Expr::Binary(BinaryOp::GreaterThanEq, Box::new(l), Box::new(r)),
    <ExprBool> => <>,
};

ExprBool: Expr = {
    <l:ExprBool> "and" <r:ExprAdd> => Expr::Binary(BinaryOp::And, Box::new(l), Box::new(r)),
    <l:ExprBool> "or" <r:ExprAdd> => Expr::Binary(BinaryOp::Or, Box::new(l), Box::new(r)),
    <l:ExprBool> "//" <r:ExprAdd> => Expr::Binary(BinaryOp::Alt, Box::new(l), Box::new(r)),
    <ExprAdd> => <>,
};

ExprAdd: Expr = {
    <l:ExprAdd> "+" <r:ExprMul> => Expr::Binary(BinaryOp::Add, Box::new(l), Box::new(r)),
    <l:ExprAdd> "-" <r:ExprMul> => Expr::Binary(BinaryOp::Sub, Box::new(l), Box::new(r)),
    <ExprMul> => <>,
};

ExprMul: Expr = {
    <l:ExprMul> "*" <r:ExprUnary> => Expr::Binary(BinaryOp::Mul, Box::new(l), Box::new(r)),
    <l:ExprMul> "/" <r:ExprUnary> => Expr::Binary(BinaryOp::Div, Box::new(l), Box::new(r)),
    <l:ExprMul> "%" <r:ExprUnary> => Expr::Binary(BinaryOp::Mod, Box::new(l), Box::new(r)),
    <ExprUnary> => <>,
};

ExprUnary: Expr = {
    "+" <ExprUnary> => Expr::Unary(UnaryOp::Pos, Box::new(<>)),
    "-" <ExprUnary> => Expr::Unary(UnaryOp::Pos, Box::new(<>)),
    <ExprField> => <>,
};

ExprField: Expr = {
    "." <f:Ident> => Expr::Field(Box::new(Expr::Identity), f),
    <e:ExprField> "." <f:Ident> => Expr::Field(Box::new(e), f),
    <e:ExprField> "[" <i:Expr?> "]" => Expr::Index(Box::new(e), i.map(Box::new)),
    <e:ExprField> "[" <l:Expr?> ":" <u:Expr?> "]" => Expr::Slice(l.map(Box::new), u.map(Box::new)),
    <ExprPrimary> => <>,
};

ExprPrimary: Expr = {
    "(" <Expr> ")" => <>,

    "." => Expr::Identity,
    ".." => Expr::Recurse,

    //<Ident> => Expr::Ident(<>),
    <Value> => Expr::Value(<>),
    "[" <e:Expr> "]" => Expr::Array(Box::new(e)),
    //<Table> => Expr::Table(<>),
    //<sym:Ident> => Expr::FnCall(sym, Vec::new()),
    <sym:Ident> "(" <args:(<Expr> ";")*> <a:Expr?> ")" => {
        let mut args = args;
        if let Some(a) = a {
            args.push(a);
        }
        Expr::FnCall(sym, args)
    },
    <Variable> => Expr::Variable(<>),

    "label" <Label> => Expr::Label(<>),
    "break" <Label> => Expr::Break(<>),
};

Stmt: Stmt = {
    "include" <String> => Stmt::IncludeMod(From::from(<>)),
    "import" <path:String> <sym:("as" <Ident>)?> => Stmt::ImportMod(From::from(path), sym),
    "import" <path:String> <var:("as" <Variable>)> => Stmt::ImportToml(From::from(path), var),
    <Expr> => Stmt::Expr(<>),
};

pub Filter: Vec<Stmt> = <stmts:(<Stmt> ";")*> <s:Stmt?> => {
    let mut stmts = stmts;
    if let Some(s) = s {
        stmts.push(s);
    }
    stmts
};
