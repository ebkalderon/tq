// vim: ft=rust

use std::str::FromStr;

use ast::{BinaryOp, Expr, Ident, Key, Label, Stmt, Table, UnaryOp, Value, Variable};

use lalrpop_util::ParseError;
use toml::value::Datetime;

grammar;

extern {
    /// TODO: Replace with proper error type.
    type Error = &'static str;
}

/// Variable types

Comma<T>: Vec<T> = <seq:(<T> ",")*> <last:T?> => seq.into_iter().chain(last).collect();

Datetime: Datetime = {
    <date:r#"([0-9]+)-(0[1-9]|1[012])-(0[1-9]|[12][0-9]|3[01])[Tt ]([01][0-9]|2[0-3]):([0-5][0-9]):([0-5][0-9]|60)(\.[0-9]+)?(([Zz])?|([\+|\-]([01][0-9]|2[0-3]):[0-5][0-9]))"#>
    => Datetime::from_str(date).unwrap(),
    <date:r#"([0-9]+)-(0[1-9]|1[012])-(0[1-9]|[12][0-9]|3[01])"#>
    => Datetime::from_str(date).unwrap(),
    <date:r#"([01][0-9]|2[0-3]):([0-5][0-9]):([0-5][0-9]|60)(\.[0-9]+)?([\+|\-]([01][0-9]|2[0-3]):[0-5][0-9])?"#>
    => Datetime::from_str(date).unwrap(),
};

Float: f64 = <num:r"[0-9]+\.[0-9]+"> => f64::from_str(num).unwrap();
Integer: i64 = <num:r"[0-9]+"> => i64::from_str(num).unwrap();

String: String = {
    <r#""[^"\\]*((\\.)*[^"\\]*)*""#> => <>[1..(<>.len()-1)].to_owned(),
    <r#"'[^'\\]*((\\.)*[^'\\]*)*'"#> => <>[1..(<>.len()-1)].to_owned(),
    <r#"'''[^'''\\]*((\\.)*[^'''\\]*)*'''"#> => <>[3..(<>.len()-3)].to_owned(),
};

Value: Value = {
    "true" => Value::Boolean(true),
    "false" => Value::Boolean(false),
    <Float> => Value::Float(<>),
    <Integer> => Value::Integer(<>),
    <String> => Value::String(<>),
    <Datetime> => Value::Datetime(<>),
    "null" => Value::Null,
};

Ident: Ident = <r"[_\-a-zA-Z]+[_\-a-zA-Z0-9]*"> => Ident(<>.to_owned());
Label: Label = "$" <Ident> => Label(<>);
Variable: Variable = "$" <Ident> => Variable(<>);

Key: Key = {
    <Ident> => Key::Ident(<>),
    <String> => Key::String(<>),
};

/// Expression types

pub Expr: Expr = <ExprPipe> => <>;

ExprPipe: Expr = {
    <l:ExprPipe> "|" <r:ExprComma> => Expr::Binary(BinaryOp::Pipe, Box::new(l), Box::new(r)),
    ExprComma,
};

ExprComma: Expr = {
    <exprs:(<ExprAssign> ",")+> <e:ExprAssign> => {
        let mut exprs = exprs;
        exprs.push(e);
        Expr::Comma(exprs)
    },
    ExprAssign,
};

ExprAssign: Expr = {
    <l:ExprAssign> "=" <r:ExprEq> => Expr::Assign(Box::new(l), Box::new(r)),
    <l:ExprAssign> "+=" <r:ExprEq> => Expr::AssignOp(BinaryOp::Add, Box::new(l), Box::new(r)),
    <l:ExprAssign> "-=" <r:ExprEq> => Expr::AssignOp(BinaryOp::Sub, Box::new(l), Box::new(r)),
    <l:ExprAssign> "*=" <r:ExprEq> => Expr::AssignOp(BinaryOp::Mul, Box::new(l), Box::new(r)),
    <l:ExprAssign> "/=" <r:ExprEq> => Expr::AssignOp(BinaryOp::Div, Box::new(l), Box::new(r)),
    <l:ExprAssign> "%=" <r:ExprEq> => Expr::AssignOp(BinaryOp::Mod, Box::new(l), Box::new(r)),
    <l:ExprAssign> "//=" <r:ExprEq> => Expr::AssignOp(BinaryOp::Alt, Box::new(l), Box::new(r)),
    <l:ExprAssign> "|=" <r:ExprEq> => Expr::AssignOp(BinaryOp::Pipe, Box::new(l), Box::new(r)),
    ExprEq,
};

ExprEq: Expr = {
    <l:ExprEq> "==" <r:ExprCmp> => Expr::Binary(BinaryOp::Eq, Box::new(l), Box::new(r)),
    <l:ExprEq> "!=" <r:ExprCmp> => Expr::Binary(BinaryOp::NotEq, Box::new(l), Box::new(r)),
    ExprCmp,
};

ExprCmp: Expr = {
    <l:ExprCmp> ">" <r:ExprBool> => Expr::Binary(BinaryOp::LessThan, Box::new(l), Box::new(r)),
    <l:ExprCmp> ">=" <r:ExprBool> => Expr::Binary(BinaryOp::LessThanEq, Box::new(l), Box::new(r)),
    <l:ExprCmp> "<" <r:ExprBool> => Expr::Binary(BinaryOp::GreaterThan, Box::new(l), Box::new(r)),
    <l:ExprCmp> "<=" <r:ExprBool> => Expr::Binary(BinaryOp::GreaterThanEq, Box::new(l), Box::new(r)),
    ExprBool,
};

ExprBool: Expr = {
    <l:ExprBool> "and" <r:ExprAdd> => Expr::Binary(BinaryOp::And, Box::new(l), Box::new(r)),
    <l:ExprBool> "or" <r:ExprAdd> => Expr::Binary(BinaryOp::Or, Box::new(l), Box::new(r)),
    <l:ExprBool> "//" <r:ExprAdd> => Expr::Binary(BinaryOp::Alt, Box::new(l), Box::new(r)),
    ExprAdd,
};

ExprAdd: Expr = {
    <l:ExprAdd> "+" <r:ExprMul> => Expr::Binary(BinaryOp::Add, Box::new(l), Box::new(r)),
    <l:ExprAdd> "-" <r:ExprMul> => Expr::Binary(BinaryOp::Sub, Box::new(l), Box::new(r)),
    ExprMul,
};

ExprMul: Expr = {
    <l:ExprMul> "*" <r:ExprUnary> => Expr::Binary(BinaryOp::Mul, Box::new(l), Box::new(r)),
    <l:ExprMul> "/" <r:ExprUnary> => Expr::Binary(BinaryOp::Div, Box::new(l), Box::new(r)),
    <l:ExprMul> "%" <r:ExprUnary> => Expr::Binary(BinaryOp::Mod, Box::new(l), Box::new(r)),
    ExprUnary,
};

ExprUnary: Expr = {
    "+" <ExprUnary> => Expr::Unary(UnaryOp::Pos, Box::new(<>)),
    "-" <ExprUnary> => Expr::Unary(UnaryOp::Pos, Box::new(<>)),
    ExprField,
};

ExprField: Expr = {
    "." <f:Ident> => Expr::Field(Box::new(Expr::Identity), f),
    <e:ExprField> "." <f:Ident> => Expr::Field(Box::new(e), f),
    <e:ExprField> "[" <i:Expr?> "]" => Expr::Index(Box::new(e), i.map(Box::new)),
    <e:ExprField> "[" <l:Expr?> ":" <u:Expr?> "]" => Expr::Slice(l.map(Box::new), u.map(Box::new)),
    ExprPrimary,
};

ExprPrimary: Expr = {
    "(" <Expr> ")" => <>,

    "." => Expr::Identity,
    ".." => Expr::Recurse,

    <Ident> => Expr::Ident(<>),
    <Value> => Expr::Value(<>),
    "[" <Comma<ExprEq>> "]" => Expr::Array(<>),
    "{" <fields:Comma<(<Key> "=" <ExprEq>)>> "}" => Expr::Table(Table { fields }),
    //<sym:Ident> => Expr::FnCall(sym, Vec::new()),
    <sym:Ident> "(" <args:(<Expr> ";")*> <a:Expr?> ")" => Expr::FnCall(sym, args.into_iter().chain(a).collect()),
    <Variable> => Expr::Variable(<>),

    "label" <Label> => Expr::Label(<>),
    "break" <Label> => Expr::Break(<>),
};

Stmt: Stmt = {
    "include" <path:String> => Stmt::IncludeMod(path.into()),
    "import" <path:String> <sym:("as" <Ident>)?> => Stmt::ImportMod(From::from(path), sym),
    "import" <path:String> <var:("as" <Variable>)> => Stmt::ImportToml(From::from(path), var),
    <Expr> => Stmt::Expr(<>),
};

pub Filter: Vec<Stmt> = <stmts:(<Stmt> ";")*> <s:Stmt?> => stmts.into_iter().chain(s).collect();
