use std::str::FromStr;

use ast::{Expr, Ident, Key, Label, Stmt, Table, UnaryOp, Value, Variable};

use toml::value::Datetime;

grammar;

Datetime: Datetime = {
    <date:r#"([0-9]+)-(0[1-9]|1[012])-(0[1-9]|[12][0-9]|3[01])[Tt ]([01][0-9]|2[0-3]):([0-5][0-9]):([0-5][0-9]|60)(\.[0-9]+)?(([Zz])?|([\+|\-]([01][0-9]|2[0-3]):[0-5][0-9]))"#>
    => Datetime::from_str(date).unwrap(),
    <date:r#"([0-9]+)-(0[1-9]|1[012])-(0[1-9]|[12][0-9]|3[01])"#>
    => Datetime::from_str(date).unwrap(),
    <date:r#"([01][0-9]|2[0-3]):([0-5][0-9]):([0-5][0-9]|60)(\.[0-9]+)?([\+|\-]([01][0-9]|2[0-3]):[0-5][0-9])?"#>
    => Datetime::from_str(date).unwrap(),
};

Float: f64 = <num:r"[0-9]+\.[0-9]+"> => f64::from_str(num).unwrap();
Integer: i64 = <num:r"[0-9]+"> => i64::from_str(num).unwrap();
String: String = {
    <r#""[^"\\]*((\\.)*[^"\\]*)*""#> => <>[1..(<>.len()-1)].to_owned(),
    <r#"'[^'\\]*((\\.)*[^'\\]*)*'"#> => <>[1..(<>.len()-1)].to_owned(),
    <r#"'''[^'''\\]*((\\.)*[^'''\\]*)*'''"#> => <>[3..(<>.len()-3)].to_owned(),
};

Ident: Ident = <r"[_\-a-zA-Z]+[_\-a-zA-Z0-9]*"> => Ident(<>.to_owned());
Label: Label = "$" <Ident> => Label(<>);
Variable: Variable = "$" <Ident> => Variable(<>);
Value: Value = {
    "true" => Value::Boolean(true),
    "false" => Value::Boolean(false),
    <Float> => Value::Float(<>),
    <Integer> => Value::Integer(<>),
    <String> => Value::String(<>),
    <Datetime> => Value::Datetime(<>),
    "null" => Value::Null,
};
Key: Key = {
    <Ident> => Key::Ident(<>),
    <String> => Key::String(<>),
};
Table: Table = "{" <fields:((<Key> "=" <Expr>))*> "}" => Table { fields };

IdentityExpr: Expr = "." => Expr::Identity;
RecurseExpr: Expr = ".." => Expr::Recurse;

IdentExpr: Expr = <Ident> => Expr::Ident(<>);
ValueExpr: Expr = <Value> => Expr::Value(<>);
ArrayExpr: Expr = "[" <arr:(<Expr> ",")*> <e:Expr?> "]" => {
    let mut arr = arr;
    if let Some(e) = e {
        arr.push(e);
    }
    Expr::Array(arr)
};
TableExpr: Expr = <t:Table> => Expr::Table(t);
FnCallExpr: Expr = {
    <sym:Ident> => Expr::FnCall(sym, Vec::new()),
    <sym:Ident> "(" <args:(<Expr> ";")*> <a:Expr?> ")" => {
        let mut args = args;
        if let Some(a) = a {
            args.push(a);
        }
        Expr::FnCall(sym, args)
    },
};
VariableExpr: Expr = <v:Variable> => Expr::Variable(v);

Expr: Expr = {
    IdentityExpr,
    RecurseExpr,

    //IdentExpr,
    ValueExpr,
    ArrayExpr,
    TableExpr,
    FnCallExpr,
    VariableExpr,
};

Stmt: Stmt = {
    "include" <String> => Stmt::IncludeMod(From::from(<>)),
    "import" <path:String> <sym:("as" <Ident>)?> => Stmt::ImportMod(From::from(path), sym),
    "import" <path:String> <var:("as" <Variable>)> => Stmt::ImportToml(From::from(path), var),
    <Expr> => Stmt::Expr(<>),
};

pub Filter: Vec<Stmt> = <stmts:(<Stmt> ";")*> <s:Stmt?> => {
    let mut stmts = stmts;
    if let Some(s) = s {
        stmts.push(s);
    }
    stmts
};
